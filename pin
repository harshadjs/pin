#!/bin/bash

REPO=$(dirname $BASH_SOURCE[0])
PROGNAME="pin"
CFG=~/.pin
TMP_CMD_FILE=.cmd
RUN_COMMAND=1
SYNC_SCRIPT=$REPO/pin-sync.sh

function pin-install() {
  echo "Welcome to $PROGNAME installation!"
  check-dependency sha1sum
  check-dependency jq
  check-dependency base64
  echo -n "Command store directory path ($HOME/.pin-db): "
  read dir
  if [ "$dir" = "" ]; then
    dir="$HOME/.pin-db"
  fi
  echo $dir
  mkdir -p $dir
  echo CMDS_DIR=$dir > ${CFG}.tmp
  echo "HIDE_SHA1=true" >> ${CFG}.tmp
  echo -n "Which folder should it install into ($HOME/bin): "
  read install_dir
  if [ "$install_dir" = "" ]; then
    install_dir="$HOME/bin"
  fi
  if [ ! -d $install_dir ]; then
    echo "Folder $install_dir not found. Exitting."
    exit 1
  fi
  cp -i $BASH_SOURCE $install_dir
  if [ "$?" != "0" ]; then
    echo "Installation failed."
    exit 1
  fi
  if [ -f $SYNC_SCRIPT ]; then
    cp $SYNC_SCRIPT $install_dir
  fi
  echo "Ensure that $install_dir is in your PATH variable."
  mv ${CFG}.tmp $CFG
  echo "Done. Prefix any command by \"pin run\" to get started."
}

function check-dependency() {
  command -v $1 > /dev/null
  if [ "$?" != "0" ]; then
    echo "Command $1 not found. Please install appropriate package."
    exit 1
  fi
}

if [ ! -f $CFG ]; then
  pin-install
  exit 0
fi

. $CFG

## Helper Functions ##
function list-all-cmds() {
  ls -t -r $CMDS_DIR/* 2>/dev/null | grep -v ".git"
}

function lookup-filename() {
  if [ -f $CMDS_DIR/$1 ]; then
    echo $CMDS_DIR/$1
    return 0
  fi
  i=0
  for filename in $(list-all-cmds); do
    if [ "$i" = "$1" ]; then
      echo $filename
      return 0
    fi
    i=$((i+1))
  done
  return 1
}

function label() {
  if [ "$HIDE_SHA1" = "true" ]; then
    echo -en "\033[4;33m$1:\033[0m  "
  else
    echo -en "\033[4;33m$1:\033[0m <$2>  "
  fi
}

## Implementation of various subcommands
function pin-sync() {
  cd $CMDS_DIR
  $SYNC_SCRIPT
}

function pin-generate-b64() {
  tar -cz $BASH_SOURCE | base64 > $PROGNAME.tar.xz.base64
  echo "$PROGNAME.tar.xz.base64 written."
}

function pin-export() {
  filename=$(lookup-filename $1)
  if [ "$?" != "0" ]; then
    echo "Command not found."
    exit 1
  fi
  sha1=$(basename $filename)
  if [ "$2" = "b64" ]; then
    base64 $filename
  else
    url=$(echo https://api.cl1p.net/$PROGNAME-$sha1-$(date +%s))
    curl -H "Content-Type: text/html; charset=UTF-8" -X POST --data "$(base64 $filename)" $url
    echo "Command exported at $url"
  fi
}

function pin-usage() {
  echo  """Usage: $PROGNAME COMMAND [ARGS]

Pin helps you organize your commands. COMMAND can be one of the
following:

   ls           List all saved commands
   ls-full      List all saved commands with description
   run          Run a new or a saved command. If running a new command
                also, ask the user the command should be saved
   import       Import a command from URL
   import-b64   Import a command as a base64 string
   export       Export a command as a cl1p.net URL
   export-b64   Export a command as a base64 string
   rm           Remove a saved command
   grep         Search for commands
   help         Print this usage
   desc         Describe a saved command
   save         Save a new command (similar to run, except don't run)
   alias        Create alias for a saved command
   fork         Fork a command
   sync         Sync your commands to your own comamands store
   generate-b64 Generate pin.tar.xz.base64 file
   install      Install pin

You can directly pass the index of the command or the SHA1 to run
the command."""
}

ran_saved=1

## Execute a command by either the index, SHA1, alias, URL or as is
function pin-exec() {
  ## Check if this is SHA1 or alias
  filename=$(lookup-filename $1)
  if [ "$?" != "0" ]; then
    url_regex='(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
    if ! [[ $1 =~ $url_regex ]]; then
      ## Not running a saved command, so just run as is.
      ran_saved=0
      eval $@
      return $?
    fi
    ## Try URL
    pin-import $1
    if [ "$?" != "0" ]; then
      return $?
    fi
    filename=$(echo $CMDS_DIR/$(basename $1 | cut -d "-" -f 2))
  fi
  pin-describe $(basename $filename)
  echo "Executing this command..."
  saved=($(cat $filename | jq .cmd -r))
  i=0
  for word in ${saved[@]}; do
    if [ "$word" = "ARG" ]; then
      if [ "$arg" = "0" ]; then
	## print the start of the command only first time
	echo -e "${saved[@]}"
      fi
      arg=1
      echo -en "${saved[@]:0:$i} <Enter Value>: "
      read var
      saved[$i]=$var
    fi
    i=$((i+1))
  done
  echo -e "\033[7;32m${saved[@]}\033[0m"
  eval ${saved[@]}
  exit $?
}

function pin-ls() {
  jq -s . $(list-all-cmds) | jq 'to_entries' | \
    jq -r '.[] | [.key, .value.cmd] | @csv' | \
    awk -v FS="," 'BEGIN{print "ID\tName"; \
    print "============"}{printf "%s\t\033[1m%s\033[0m%s",$1,substr($2, 2, length($2)-2),ORS}'
}

function pin-fork() {
  if [ "$EDITOR" = "" ]; then
    echo "\$EDITOR not set."
    return
  fi
  filename=$(lookup-filename $1)
  if [ "$?" != "0" ]; then
      return
  fi

  cp $filename ${filename}.fork
  $EDITOR ${filename}.fork
  dest_filename=$(cat ${filename}.fork | jq -r .cmd | sha1sum - | cut -d " " -f1 2>/dev/null)
  mv ${filename}.fork $CMDS_DIR/$dest_filename
  echo "Created $dest_filename"
}

function pin-import() {
  if [ "$1" = "b64" ]; then
    echo "Text mode. Enter the string that you got from pin export-b64. Ctrl D to stop:"
    cat | base64 -d - > $CMDS_DIR/new-import
  else
    b64=$(curl $1)
    if [ "$?" != "0" ]; then
      echo "Import failed."
      return 1
    fi
    echo "$b64" | base64 -d - > $CMDS_DIR/new-import
  fi
  cmd=$(cat $CMDS_DIR/new-import | jq -r .cmd)
  if [ "$cmd" = "" ]; then
    echo "No command imported."
    rm $CMDS_DIR/new-import
    return 1
  fi
  sha1=$(cat $CMDS_DIR/new-import | jq -r .cmd | sha1sum - | cut -d " " -f1 2>/dev/null)
  mv $CMDS_DIR/new-import $CMDS_DIR/$sha1
  echo "Imported $sha1."
  return 0
}

function pin-run() {
  if [ "$RUN_COMMAND" = "1" ]; then
    ran_saved=1
    pin-exec $@
    rc=$?
    if [ "$ran_saved" = "1" ]; then
      exit $rc
    fi
    echo -n "Save command [y/N]? "
    read save
    if [ "$save" != "y" -a "$save" != "Y" ]; then
      exit $rc
    fi
  else
    rc=0
  fi

  ## Save this command
  echo ""
  a=($(echo $@ | xargs))
  i=0
  echo -n "Command entered: "
  for word in ${a[@]}; do
    echo -en "\033[0;33m($i)\033[0m$word "
    i=$((i+1))
  done
  echo -e ""
  echo -n "Enter the indices from above command that are arguments (enter to skip): "
  read args
  b=""
  for word in $args; do
    a[$word]="ARG"
  done
  b=""
  for word in ${a[@]}; do
    b=$(echo -n "$b $word")
  done
  b=$(echo $b | xargs)
  echo -e "Command to be saved: \033[0;33m$b\033[0m"
  echo $b > $TMP_CMD_FILE

  echo -n "Short Description (enter to skip): "
  read description
  if [ "$description" != "" ]; then
    echo "## $description" >> $TMP_CMD_FILE
  fi
  echo "{\"cmd\": \"${b}\", \"desc\": \"${description}\"}" | jq . > $TMP_CMD_FILE
  id=$(echo $b | sha1sum - | cut -d " " -f1)
  mv $TMP_CMD_FILE $CMDS_DIR/$id
  echo "Created $id."
  echo -n "Alias (enter to skip): "
  read alias
  if [ "$alias" != "" ]; then
    if [ $(echo $alias | wc -w) = "1" ]; then
      ln -s $CMDS_DIR/$id $CMDS_DIR/$alias
      echo "Create alias \"$alias\"."
    else
      echo "Error: alias can only be one word."
    fi
  fi
  exit $rc
}

function pin-rm {
  pin-ls
  echo -n "Enter index of the command to delete: "
  read cmd
  filename=$(lookup-filename $cmd)
  if [ "$?" != "0" ]; then
    return $?
  fi
  pin-describe $cmd
  echo -n "Delete above command? [y/N]: "
  read confirm
  if [ "$confirm" != "y" -a "$confirm" != "Y" ]; then
    echo "Nothing deleted."
    return 0
  fi
  rm $filename
  find $CMDS_DIR -xtype l -delete
  echo "Deleted."
}

function pin-describe {
  filename=$(lookup-filename $1)
  if [ "$?" != "0" ]; then
    echo "Command not found."
    exit 1
  fi
  echo "SHA1:		$(basename $filename)"
  echo -n "Command:	"
  cat $filename | jq -r .cmd
  echo -n "Description:	"
  cat $filename | jq -r .desc
}

function pin-grep {
  jq -s . $(list-all-cmds) | jq 'to_entries' | \
    jq -r --arg filter $1 '.[] | select((.value.desc | contains($filter)) or (.value.cmd | contains($filter))) | [.key, .value.cmd, .value.desc] | @csv' | \
    awk -v FS="," \
    'BEGIN{print "ID\tText";print "============"} \
    {printf "\033[1m%s\033[0m\t\033[1m%s\033[0m\n\t%s%s",$1,substr($2, 2, length($2)-2),$3,ORS}'
}

function pin-alias {
  if [ "o$#" != 2 ]; then
    echo "Usage: $PROGNAME alias <command-id> <alias>"
    exit 1
  fi
  filename=$(lookup-filename $1)
  if [ "$?" != "0" ]; then
    echo "Command not found."
    exit 1
  fi
  ln -s $filename $CMDS_DIR/$2
  echo "Created alias $2 for command $1"
}

if [ "$#" = "0" ]; then
  pin-usage
  exit 1
fi

if [ "$1" = "ls" ]; then
  pin-ls
elif [ "$1" = "ls-full" ]; then
  pin-ls full
elif [ "$1" = "rm" ]; then
  pin-rm
elif [ "$1" = "sync" ]; then
  pin-sync
elif [ "$1" = "import" ]; then
  pin-import $2
elif [ "$1" = "import-b64" ]; then
  pin-import $2 b64
elif [ "$1" = "export" ]; then
  pin-export $2
elif [ "$1" = "export-b64" ]; then
  pin-export $2 b64
elif [ "$1" = "grep" ]; then
  pin-grep $2
elif [ "$1" = "help" ]; then
  pin-usage
elif [ "$1" = "desc" ]; then
  pin-describe $2
elif [ "$1" = "run" ]; then
  shift
  pin-run $@
elif [ "$1" = "alias" ]; then
  shift
  pin-alias $@
elif [ "$1" = "save" ]; then
  RUN_COMMAND=0
  shift
  pin-run $@
elif [ "$1" = "fork" ]; then
  shift
  pin-fork $@
elif [ "$1" = "install" ]; then
  pin-install
elif [ "$1" = "generate-b64" ]; then
  pin-generate-b64
else
  echo "Unknown command $1."
  pin-usage
  exit 1
fi
