#!/bin/bash

## Environment Variables
##
## PIN_INPUT=<filename> Turns pin into non-interactive mode.
##                      if set, pin will read line by line from
##                      <filename> whenever interactions are happening.
## PIN_CFG=<filename>   Makes pin use alternate config file instead
##                      of ~/.pin
## PIN_USE_CACHED=1	Doesn't ask for user input whenever cached
##			values are available

## Global Constants
REPO=$(dirname $BASH_SOURCE[0])
PROGNAME="pin"
CFG=~/.pin
TMP_CMD_FILE=.cmd
SYNC_SCRIPT=$REPO/pin-sync.sh
URL_REGEX='(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
CACHE=~/.pin-cache
ALIAS_FILE=~/.pin-alias
CL1P_NAMESPACE=harshads
LS_OUTPUT_CACHE=/tmp/pin-ls-cache
GREP_CACHE=/tmp/pin-grep-cache/

## All possible commands
ALL_COMMANDS=(
    ls		## 0
    rm		## 1
    sync	## 2
    i import	## 4
    ib64 import-b64	## 6
    e export	## 7 8
    eb64 export-b64	## 9 10
    grep	## 11
    desc describe	## 12 13
    watch	## 14
    run		## 15
    tags	## 16
    dump	## 17
    fork	## 18
    install	## 19
    generate-b64	## 20
    sv save save-cmd	## 21 22 23
    svb save-blob	## 24 25
    svs save-script	## 26 27
    cr create create-script	## 28 29 30
    crb create-blob	## 31 32
    crc create-cmd	## 33 34
    cc clear-cache	## 35 36
)

## Global Control Variables
g_pin_input_line=1
g_pin_input_cached=0
g_add_blob_tag=0

## Helper functions
function _get_tmp_file() {
    echo "/tmp/pin-$(date +%s)"
}

function _clear_caches() {
    rm -rf $GREP_CACHE $LS_OUTPUT_CACHE
}

function _read() {
    if [ "$PIN_INPUT" != "" ]; then
	val=$(echo '$(sed "${g_pin_input_line}q;d" $PIN_INPUT)')
	eval $1=$val
	g_pin_input_line=$((g_pin_input_line+1))
	if [ "$g_pin_input_cached" != "0" ]; then
	    eval c=\$$1
	    echo -n [$c]
	    if [ "$PIN_USE_CACHED" = "" ]; then
		read newval < /dev/tty
	    else
		echo ""
	    fi
	    if [ "$newval" != "" ]; then
		eval $1=$newval
	    fi
	else
	    echo ""
	fi
    else
	read $1 < /dev/tty
    fi
}

function _confirm() {
    echo -n "$1 [y/N]: "
    _read cnf
    if [ "$cnf" != "y" -a "$cnf" != "Y" ]; then
	echo "Cancelled."
	return 1
    fi
    return 0
}

function _upload_to_cl1p() {
    filename=$1
    url=$2
    base64 $filename | curl -H "Content-Type: text/html; charset=UTF-8" -X POST --data-binary @- $url
}

function _check_dependency() {
    command -v $1 > /dev/null
    if [ "$?" != "0" ]; then
	return 1
    fi
    return 0
}

function _fail() {
    echo $1
    exit 1
}

function _list_all() {
    ls $CMDS_DIR/* -tr 2>/dev/null | grep -v ".git"
}

## Lookup a command
## $1:  SHA1 of the command
function _lookup() {
    if [ -f $CMDS_DIR/$1 ]; then
	echo $CMDS_DIR/$1
	return 0
    fi
    i=0
    for filename in $(_list_all); do
	if [ "$i" = "$1" ]; then
	    echo $filename
	    return 0
	fi
	i=$((i+1))
    done
    return 1
}

function _print_cmd() {
    echo -en "$CMD_ID\t"
    if [ "$TYPE" = "cmd" ]; then
	echo -ne "${NEW}$(echo $CMD | base64 -d - | head -c 80)"
	len=$(echo $CMD | base64 -d - | wc -m)
	if [ $len -ge 80 ]; then
	    echo -n "..."
	fi
	echo -e "${STOP}"
    elif [ "$TYPE" = "script" ]; then
	echo -e "${YELLOW}<script>${STOP}"
    elif [ "$TYPE" = "blob" ]; then
	echo -e "${YELLOW}<blob>${STOP}"
    fi
    echo -e "\t($DESC)"
    echo ""
}

function _print_hdr() {
    echo -e "${BOLD}ID      Command${STOP}"
    echo "==============="
}

function _save() {
    _clear_caches

    cmdfile="$1"
    if [ "$2" = "cmd" ]; then
	command="$(cat $cmdfile | xargs | base64 -w 0)"
    else
	command="$(cat $cmdfile | base64 -w 0)"
    fi
    id=$(echo $command | sha1sum - | cut -d " " -f1)
    if [ -f $CMDS_DIR/$id ]; then
	_confirm "Command exists. Overwrite?" || return 0
    fi
    echo -n "Short Description (enter to skip): "
    _read description
    echo -n "Alias (enter to skip): "
    _read alias
    if [ "$alias" != "" ]; then
     	echo "alias ${alias}=\"pin run $id\"" >> $ALIAS_FILE
    fi
    echo "CMD=\"$command\"" > $CMDS_DIR/$id
    echo "DESC=\"$description\"" >> $CMDS_DIR/$id
    echo "TYPE=$2" >> $CMDS_DIR/$id
    echo "Created $id."
}

## Execute a command by either the index, SHA1, URL or as is
## $1:      Variable that will be set as 1 or 0 depending on whether
##          the command that was passed, if that was a saved command
##          or not
## ${@:2}:  Command / URL / SHA1 / index
function _exec() {
    ## Check if this is SHA1 or index
    ran_saved=$1
    shift
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	## Is it a url?
	if ! [[ $1 =~ $URL_REGEX ]]; then
	    ## Not a url, not a saved command, run as is.
	    eval $ran_saved=0
	    eval $@
	    return $?
	fi
	pin-import $1
	if [ "$?" != "0" ]; then
	    return $?
	fi
	filename=$(echo $CMDS_DIR/$(basename $1 | cut -d "-" -f 2))
    fi
    pin-describe $(basename $filename)
    eval $ran_saved=1
    echo "Executing this command..."
    . $filename
    if [ "$TYPE" = "script" ]; then
	TMP_CMD_FILE=$(_get_tmp_file)
	echo $CMD | base64 -d - > $TMP_CMD_FILE
	$WATCH bash $TMP_CMD_FILE
	ret=$?
	rm $TMP_CMD_FILE
	return $ret
    elif [ "$TYPE" = "blob" ]; then
	echo "Can't run a blob"
    else
	line=$(echo $CMD | base64 -d -)
	tokens=($line)
	i=0
	if [ "$PIN_INPUT" = "" -a -f $CACHE/$(basename $filename) ]; then
	    g_pin_input_cached=1
	    g_pin_input_line=2
	    PIN_INPUT=$CACHE/$(basename $filename)
	fi
	cache_file=$(_get_tmp_file)
	echo "" > $cache_file
	for token in ${tokens[@]}; do
	    if [ "$token" = "ARG" ]; then
		if [ "$i" = "0" ]; then
		    ## print the start of the command only first time
		    echo -e "${tokens[@]}"
		fi
		echo -en "${tokens[@]:0:$i} <Enter Value>: "
		_read var
		tokens[$i]=$var
		echo "$var" >> $cache_file
	    fi
	    i=$((i+1))
	done
	mv $cache_file $CACHE/$(basename $filename)
	if [ "$g_pin_input_cached" = "1" ]; then
	    g_pin_input_cached=0
	    PIN_INPUT=""
	fi
	echo -e "$DARKGREENBG${tokens[@]}$STOP"
	$WATCH eval ${tokens[@]}
	return $?
    fi
}

##
## Handlers for subcommands
##
function pin-usage() {
    echo  """Usage: $PROGNAME COMMAND [ARGS]

Pin helps you organize your commands. COMMAND can be one of the
following:

You can directly pass the index of the command or the SHA1 to run
the command.
"""

    PIN_USAGE_MODE=1
    for cmd in ${ALL_COMMANDS[@]}; do
	pin-cmd-handler $cmd
    done
}

function pin-install() {
    echo "Welcome to $PROGNAME installation!"
    _check_dependency sha1sum || _check_dependency shasum || \
	_fail "sha1sum or shasum not found"
    _check_dependency base64 || _fail "base64 not found"
    echo -n "Command store directory path ($HOME/.pin-db): "
    _read dir
    if [ "$dir" = "" ]; then
	dir="$HOME/.pin-db"
    fi
    mkdir -p $dir
    echo CMDS_DIR=$dir > ${CFG}.tmp
    echo -n "Which folder should it install into ($HOME/bin): "
    _read install_dir
    if [ "$install_dir" = "" ]; then
	install_dir="$HOME/bin"
    fi
    if [ ! -d $install_dir ]; then
	_fail "Folder $install_dir not found. Exitting."
    fi
    cp -i $BASH_SOURCE $install_dir
    if [ "$?" != "0" ]; then
	_fail "Installation failed."
    fi
    if [ -f $SYNC_SCRIPT ]; then
	cp $SYNC_SCRIPT $install_dir
    fi
    echo "Ensure that $install_dir is in your PATH variable."
    mv ${CFG}.tmp $CFG
    echo "Add following line in your <sh>rc file for alias support:"
    echo ". $ALIAS_FILE "
    echo "Done. Prefix any command by \"pin run\" to get started."
}

function pin-sync() {
    cd $CMDS_DIR
    $SYNC_SCRIPT
}

function pin-generate-b64() {
    tar -cz $BASH_SOURCE | base64 > $PROGNAME.tar.xz.base64
    echo "$PROGNAME.tar.xz.base64 written."
}

function pin-export() {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	return 1
    fi
    sha1=$(basename $filename)
    pin-describe $sha1
    _confirm "Export above command?" || return 0
    if [ "$2" = "b64" ]; then
	base64 $filename
    else
	url=$(echo https://api.cl1p.net/$PROGNAME-$CL1P_NAMESPACE-$sha1)
	_upload_to_cl1p $filename $url
	echo "Command exported at $url"
    fi
}

function pin-ls() {
    CMD_ID=0

    if [ ! -f "$LS_OUTPUT_CACHE" ]; then
	echo "" > $LS_OUTPUT_CACHE
	_print_hdr > $LS_OUTPUT_CACHE
	for file in $(_list_all); do
	    . $file
	    _print_cmd >> $LS_OUTPUT_CACHE
	    CMD_ID=$((CMD_ID+1))
	done
    fi

    cat $LS_OUTPUT_CACHE | less
}

function pin-tags() {
    grep -o ':\w*:' -R $CMDS_DIR -h --exclude-dir .git --color=auto | \
	sort --unique
}

function pin-fork() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi

    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	return
    fi
    . $filename
    TMP_CMD_FILE=$(_get_tmp_file)
    echo "$CMD" | base64 -d - > $TMP_CMD_FILE
    $EDITOR $TMP_CMD_FILE
    _save $TMP_CMD_FILE $TYPE
}

function pin-create() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi
    TMP_CMD_FILE=$(_get_tmp_file)
    $EDITOR $TMP_CMD_FILE
    _save $TMP_CMD_FILE $1
}

function pin-import() {
    TMP_CMD_FILE=$(_get_tmp_file)
    if [ "$1" = "b64" ]; then
	echo "Text mode. Enter the string that you got from pin export-b64. Ctrl D to stop:"
	cat | base64 -d - > $TMP_CMD_FILE
    else
	b64=$(curl $1)
	if [ "$?" != "0" ]; then
	    echo "Import failed."
	    return 1
	fi
	echo "$b64" | base64 -d - > $TMP_CMD_FILE
    fi
    . $TMP_CMD_FILE
    if [ "$CMD" = "" ]; then
	echo "No command imported."
	rm $TMP_CMD_FILE
	return 1
    fi
    sha1=$(echo $CMD | sha1sum - | cut -d " " -f1 2>/dev/null)
    if [ -f $CMDS_DIR/$sha1 ]; then
	echo "Command $sha1 exists."
	return 0
    fi
    mv $TMP_CMD_FILE $CMDS_DIR/$sha1
    echo "Imported $sha1."
    pin-describe $sha1
    _clear_caches
    return 0
}

function pin-save() {
    echo ""
    a=($(echo $@ | xargs))
    i=0
    echo -n "Command entered: "
    TMP_CMD_FILE=$(_get_tmp_file)
    for word in ${a[@]}; do
	echo -en "$YELLOW($i)$STOP$word "
	i=$((i+1))
    done
    echo -e ""
    echo -n "Enter the indices from above command that are arguments (enter to skip): "
    _read args
    b=""
    for word in $args; do
	a[$word]="ARG"
    done
    b=""
    for word in ${a[@]}; do
	b=$(echo -n "$b $word")
    done
    echo "$b" > $TMP_CMD_FILE
    echo -e "Command to be saved: $YELLOW$b$STOP"
    _save $TMP_CMD_FILE cmd
    rm $TMP_CMD_FILE
}

function pin-save-blob() {
    TMP_CMD_FILE=$(_get_tmp_file)
    if [ "$1" != "" ]; then
	cat $1 > $TMP_CMD_FILE
    else
	cat > $TMP_CMD_FILE
    fi
    _save $TMP_CMD_FILE blob
    rm $TMP_CMD_FILE
}

function pin-save-script() {
    TMP_CMD_FILE=$(_get_tmp_file)
    if [ "$1" != "" ]; then
	cat $1 > $TMP_CMD_FILE
    else
	cat > $TMP_CMD_FILE
    fi
    _save $TMP_CMD_FILE script
    rm $TMP_CMD_FILE
}

function pin-rm {
    _clear_caches
    cmd=$1
    filename=$(_lookup $cmd)
    if [ "$?" != "0" ]; then
	return $?
    fi
    pin-describe $cmd
    _confirm "Delete above command?" || return 0
    rm $filename
    find $CMDS_DIR -xtype l -delete
    echo "Deleted."
}

function pin-describe {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	return 1
    fi
    . $filename

    echo -e "SHA1:		${BOLD}$(basename $filename)${STOP}"
    echo -e "Command:	${BOLD}$(echo $CMD | base64 -d -)${STOP}"
    echo -e "Description:	$DESC"
}

function pin-dump {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	_fail "Object not found."
    fi
    . $filename
    echo $CMD | base64 -d -
}

function pin-grep() {
    CMD_ID=0
    if [ -f $GREP_CACHE/$1 ]; then
	cat $GREP_CACHE/$1
	return
    fi
    mkdir -p $GREP_CACHE
    _print_hdr > $GREP_CACHE/$1
    for file in $(_list_all); do
	. $file
	echo "$(echo $CMD | base64 -d -) $DESC" | grep -i $1 > /dev/null
	if [ "$?" = "0" ]; then
	    _print_cmd  >> $GREP_CACHE/$1
	fi
	CMD_ID=$((CMD_ID+1))
    done
    cat $GREP_CACHE/$1
}

function pin-cmd-handler() {
    case "$1" in
	"${ALL_COMMANDS[0]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  ls\t\t\t\tList all commands"
		return
	    fi
	    pin-ls
	    ;;
	"${ALL_COMMANDS[1]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  rm <cmd>\t\t\tRemove a specific command"
		return
	    fi
	    shift
	    pin-rm $@
	    ;;
	"${ALL_COMMANDS[2]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  sync\t\t\t\tSync commands"
		return
	    fi
	    pin-sync
	    ;;
	"${ALL_COMMANDS[3]}" | "${ALL_COMMANDS[4]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[3]}" ]; then
		    echo -e "  ${ALL_COMMANDS[3]} | ${ALL_COMMANDS[4]} <url>\t\tImport a new command from url"
		fi
		return
	    fi
	    pin-import $2
	    ;;
	"${ALL_COMMANDS[5]}" | "${ALL_COMMANDS[6]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[5]}" ]; then
		    echo -e "  ${ALL_COMMANDS[5]} | ${ALL_COMMANDS[6]}\t\tImport a new command from base64 string"
		fi
		return
	    fi
	    pin-import $2 b64
	    ;;
	"${ALL_COMMANDS[7]}" | "${ALL_COMMANDS[8]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[7]}" ]; then
		    echo -e "  ${ALL_COMMANDS[7]} | ${ALL_COMMANDS[8]}\t\t\tExport a saved command as url"
		fi
		return
	    fi
	    pin-export $2
	    ;;
	"${ALL_COMMANDS[9]}" | "${ALL_COMMANDS[10]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[9]}" ]; then
		    echo -e "  ${ALL_COMMANDS[9]} | ${ALL_COMMANDS[10]}\t\tExport a saved command as a base64 encoded string"
		fi
		return
	    fi
	    pin-export $2 b64
	    ;;
	"${ALL_COMMANDS[11]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  grep <term>\t\t\tSearch commands matching the passed term"
		return
	    fi
	    pin-grep $2
	    ;;
	"${ALL_COMMANDS[12]}" | "${ALL_COMMANDS[13]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[12]}" ]; then
		    echo -e "  ${ALL_COMMANDS[12]} | ${ALL_COMMANDS[13]} <cmd>\t\tDescribe a saved command"
		fi
		return
	    fi
	    pin-describe $2
	    ;;
	"${ALL_COMMANDS[14]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  watch <cmd>\t\t\tWatch a command"
		return
	    fi
	    WATCH=watch
	    ;&
	"${ALL_COMMANDS[15]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  run <cmd>\t\t\tRun a command"
		return
	    fi
	    shift
	    _exec ran_saved $@
	    rc=$?
	    if [ "$ran_saved" = "1" ]; then
		exit $rc
	    fi
	    echo -n "Save command [y/N]? "
	    _read save
	    if [ "$save" != "y" -a "$save" != "Y" ]; then
		exit $rc
	    fi
	    ;;
	"${ALL_COMMANDS[16]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  tags <cmd>\t\t\tShow all tags"
		return
	    fi
	    shift
	    pin-tags $@
	    ;;
	"${ALL_COMMANDS[17]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  dump <cmd>\t\t\tDump command / script or blob to stdout"
		return
	    fi
	    pin-dump $2
	    ;;
	"${ALL_COMMANDS[18]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  fork <cmd>\t\t\tFork a command to create a new one"
		return
	    fi
	    shift
	    pin-fork $@
	    ;;
	"${ALL_COMMANDS[19]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  install\t\t\tInstall pin"
		return
	    fi
	    pin-install
	    ;;
	"${ALL_COMMANDS[20]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		echo -e "  generate-b64\t\t\tGenerate pin base64 encoded package"
		return
	    fi
	    pin-generate-b64
	    ;;
	"${ALL_COMMANDS[21]}" | "${ALL_COMMANDS[22]}" | "${ALL_COMMANDS[23]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[21]}" ]; then
		    echo -e "  ${ALL_COMMANDS[21]} | ${ALL_COMMANDS[22]}| ${ALL_COMMANDS[23]} <str>\tSave a new command"
		fi
		return
	    fi
	    shift
	    pin-save $@
	    ;;
	"${ALL_COMMANDS[24]}" | "${ALL_COMMANDS[25]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[24]}" ]; then
		    echo -e "  ${ALL_COMMANDS[24]} | ${ALL_COMMANDS[25]}\t\tSave a new blob from stdin"
		fi
		return
	    fi
	    shift
	    pin-save-blob $@
	    ;;
	"${ALL_COMMANDS[26]}" | "${ALL_COMMANDS[27]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[26]}" ]; then
		    echo -e "  ${ALL_COMMANDS[26]} | ${ALL_COMMANDS[27]}\t\tSave a new script from stdin"
		fi
		return
	    fi
	    shift
	    pin-save-script $@
	    ;;
	"${ALL_COMMANDS[28]}" | "${ALL_COMMANDS[29]}" | "${ALL_COMMANDS[30]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[28]}" ]; then
		    echo -e "  ${ALL_COMMANDS[28]} | ${ALL_COMMANDS[29]}| ${ALL_COMMANDS[30]}\tOpen editor to create and save a new script"
		fi
		return
	    fi
	    pin-create script
	    ;;
	"${ALL_COMMANDS[31]}" | "${ALL_COMMANDS[32]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[31]}" ]; then
		    echo -e "  ${ALL_COMMANDS[31]} | ${ALL_COMMANDS[32]}\t\tOpen editor to create and save a new blob"
		fi
		return
	    fi
	    pin-create blob
	    ;;
	"${ALL_COMMANDS[33]}" | "${ALL_COMMANDS[34]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[33]}" ]; then
		    echo -e "  ${ALL_COMMANDS[33]} | ${ALL_COMMANDS[34]}\t\tOpen editor to create and save a new command"
		fi
		return
	    fi
	    pin-create cmd
	    ;;
	"${ALL_COMMANDS[35]}" | "${ALL_COMMANDS[36]}")
	    if [ "$PIN_USAGE_MODE" = "1" ]; then
		if [ "$1" = "${ALL_COMMANDS[35]}" ]; then
		    echo -e "  ${ALL_COMMANDS[35]} | ${ALL_COMMANDS[36]}\t\tClear all caches"
		fi
		return
	    fi
	    _clear_caches
	    ;;
	*)
	    echo "Unknown command $1."
	    pin-usage
    esac
}

function main() {
    ## Should we use alternate config file?
    if [ "$PIN_CFG" != "" ]; then
	CFG=$PIN_CFG
    fi
    if [ "$PIN_CACHE" != "" ]; then
	CACHE=$PIN_CACHE
    fi
    mkdir -p $CACHE
    if [ "$PIN_ALIAS_FILE" != "" ]; then
	ALIAS_FILE=$PIN_ALIAS_FILE
    fi

    if [ ! -f $CFG ]; then
	pin-install
	exit 0
    fi

    . $CFG

    if [ "$#" = "0" ]; then
	pin-usage
	exit 1
    fi

    if [ "$COLOURED_OUTPUT" != "false" ]; then
	YELLOW="\033[0;33m"
	DARKGREENBG="\033[7;32m"
	BOLD="\033[1m"
	NEW="\033[1;32m"
	STOP="\033[0m"
    fi
    
    pin-cmd-handler $@
}

main $@
