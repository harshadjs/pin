#!/bin/bash

## Environment Variables
##
## PIN_INPUT=<filename> Turns pin into non-interactive mode.
##                      if set, pin will read line by line from
##                      <filename> whenever interactions are happening.
## PIN_CFG=<filename>   Makes pin use alternate config file instead
##                      of ~/.pin

REPO=$(dirname $BASH_SOURCE[0])
PROGNAME="pin"
CFG=~/.pin
TMP_CMD_FILE=.cmd
RUN_COMMAND=1
SYNC_SCRIPT=$REPO/pin-sync.sh
SHA_PROG=""
PIN_INPUT_LINE=1

function pin-read-handler() {
    if [ "$PIN_INPUT" != "" ]; then
	val=$(echo '$(sed "${PIN_INPUT_LINE}q;d" $PIN_INPUT)')
	eval $1=$val
	PIN_INPUT_LINE=$((PIN_INPUT_LINE+1))
	echo ""
    else
	read $1 < /dev/tty
    fi
}

function pin-install() {
    echo "Welcome to $PROGNAME installation!"
    check-dependency sha1sum || check-dependency shasum || \
	_fail "sha1sum or shasum not found"
    check-dependency jq || _fail "jq not found"
    check-dependency base64 || _fail "base64 not found"
    echo -n "Command store directory path ($HOME/.pin-db): "
    pin-read-handler dir
    if [ "$dir" = "" ]; then
	dir="$HOME/.pin-db"
    fi
    mkdir -p $dir
    echo CMDS_DIR=$dir > ${CFG}.tmp
    echo "HIDE_SHA1=true" >> ${CFG}.tmp
    echo -n "Which folder should it install into ($HOME/bin): "
    pin-read-handler install_dir
    if [ "$install_dir" = "" ]; then
	install_dir="$HOME/bin"
    fi
    if [ ! -d $install_dir ]; then
	echo "Folder $install_dir not found. Exitting."
	exit 1
    fi
    cp -i $BASH_SOURCE $install_dir
    if [ "$?" != "0" ]; then
	echo "Installation failed."
	exit 1
    fi
    if [ -f $SYNC_SCRIPT ]; then
	cp $SYNC_SCRIPT $install_dir
    fi
    echo "Ensure that $install_dir is in your PATH variable."
    mv ${CFG}.tmp $CFG
    echo "Done. Prefix any command by \"pin run\" to get started."
}

function check-dependency() {
    command -v $1 > /dev/null
    if [ "$?" != "0" ]; then
	return 1
    fi
    return 0
}

function _fail() {
    echo $1
    exit 1
}

## Helper Functions ##
function list-all-cmds() {
    ls $CMDS_DIR/* 2>/dev/null | sort | grep -v ".git"
}

function lookup-filename() {
    if [ -f $CMDS_DIR/$1 ]; then
	echo $CMDS_DIR/$1
	return 0
    fi
    i=0
    for filename in $(list-all-cmds); do
	if [ "$i" = "$1" ]; then
	    echo $filename
	    return 0
	fi
	i=$((i+1))
    done
    return 1
}

## Implementation of various subcommands
function pin-sync() {
    cd $CMDS_DIR
    $SYNC_SCRIPT
}

function pin-generate-b64() {
    tar -cz $BASH_SOURCE | base64 > $PROGNAME.tar.xz.base64
    echo "$PROGNAME.tar.xz.base64 written."
}

function pin-export() {
    filename=$(lookup-filename $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	exit 1
    fi
    sha1=$(basename $filename)
    pin-describe $sha1
    confirm "Export above command?" || return 0
    if [ "$2" = "b64" ]; then
	base64 $filename
    else
	url=$(echo https://api.cl1p.net/$PROGNAME-$sha1-$(date +%s))
	curl -H "Content-Type: text/html; charset=UTF-8" -X POST --data "$(base64 $filename)" $url
	echo "Command exported at $url"
    fi
}

function pin-usage() {
    echo  """Usage: $PROGNAME COMMAND [ARGS]

Pin helps you organize your commands. COMMAND can be one of the
following:

   ls           List all saved commands
   run          Run a new or a saved command. If running a new command
                also, ask the user the command should be saved
   import       Import a command from URL
   import-b64   Import a command as a base64 string
   export       Export a command as a cl1p.net URL
   export-b64   Export a command as a base64 string
   rm           Remove a saved command
   grep         Search for commands
   help         Print this usage
   desc         Describe a saved command
   save         Save a new command (similar to run, except don't run)
   alias        Create alias for a saved command
   fork         Fork a command
   create       Create a new command. (useful for saving scripts)
   sync         Sync your commands to your own comamands store
   generate-b64 Generate pin.tar.xz.base64 file
   install      Install pin
   tags         List all tags

You can directly pass the index of the command or the SHA1 to run
the command."""
}

ran_saved=1

## Execute a command by either the index, SHA1, alias, URL or as is
function pin-exec() {
    ## Check if this is SHA1 or alias
    filename=$(lookup-filename $1)
    if [ "$?" != "0" ]; then
	url_regex='(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
	if ! [[ $1 =~ $url_regex ]]; then
	    ## Not running a saved command, so just run as is.
	    ran_saved=0
	    eval $@
	    return $?
	fi
	## Try URL
	pin-import $1
	if [ "$?" != "0" ]; then
	    return $?
	fi
	filename=$(echo $CMDS_DIR/$(basename $1 | cut -d "-" -f 2))
    fi
    pin-describe $(basename $filename)
    echo "Executing this command..."
    while read line; do
	saved=($line)
	i=0
	for word in ${saved[@]}; do
	    if [ "$word" = "ARG" ]; then
		if [ "$arg" = "0" ]; then
		    ## print the start of the command only first time
		    echo -e "${saved[@]}"
		fi
		echo -en "${saved[@]:0:$i} <Enter Value>: "
		pin-read-handler var
		saved[$i]=$var
	    fi
	    i=$((i+1))
	done
	echo -e "\033[7;32m${saved[@]}\033[0m"
	eval ${saved[@]}
    done < <(cat $filename | jq -r .cmd)
    exit $?
}

function parse-cmd-out() {
    if [ $COLOURED_OUTPUT = "false" ]; then
	awk -v FS="," \
	    'BEGIN{print "ID\tCommand";print "==============="}          \
  	      	{printf "%s\t\%s\n\t%s%s",        \
		    substr($1,2,length($1)),substr($2,3,length($2)-4),substr($3,3,length($3)-5),ORS	}'
    else
	awk -v FS="," \
	    'BEGIN{print "ID\tCommand";print "==============="}          \
  	      	{printf "\033[1m%s\033[0m\t\033[1m%s\033[0m\n\t%s%s",        \
		    substr($1,2,length($1)),substr($2,3,length($2)-4),substr($3,3,length($3)-5),ORS}'
    fi
}

function pin-ls() {
    jq -s . $(list-all-cmds) | jq 'to_entries' | \
	jq  '.[] | [.key, .value.cmd, .value.desc] | @csv' | parse-cmd-out
}

function pin-tags() {
    grep -o ':\w*:' -R $CMDS_DIR -h --exclude-dir .git --color=auto | sort --unique
}

function pin-fork() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi
    filename=$(lookup-filename $1)
    if [ "$?" != "0" ]; then
	return
    fi

    cp $filename ${filename}.fork
    $EDITOR ${filename}.fork
    dest_filename=$(cat ${filename}.fork | jq -r .cmd | sha1sum - | cut -d " " -f1 2>/dev/null)
    mv ${filename}.fork $CMDS_DIR/$dest_filename
    echo "Created $dest_filename"
}

function pin-create() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi
    $EDITOR ".new-cmd"
    sed 's/$/\\n/' .new-cmd | tr -d '\n' > .new-cmd-trimmed
    pin-save .new-cmd-trimmed notrim
}

function pin-import() {
    if [ "$1" = "b64" ]; then
	echo "Text mode. Enter the string that you got from pin export-b64. Ctrl D to stop:"
	cat | base64 -d - > $CMDS_DIR/new-import
    else
	b64=$(curl $1)
	if [ "$?" != "0" ]; then
	    echo "Import failed."
	    return 1
	fi
	echo "$b64" | base64 -d - > $CMDS_DIR/new-import
    fi
    cmd=$(cat $CMDS_DIR/new-import | jq -r .cmd)
    if [ "$cmd" = "" ]; then
	echo "No command imported."
	rm $CMDS_DIR/new-import
	return 1
    fi
    sha1=$(cat $CMDS_DIR/new-import | jq -r .cmd | sha1sum - | cut -d " " -f1 2>/dev/null)
    if [ -f $CMDS_DIR/$sha1 ]; then
	echo "Command $sha1 exists."
	new_desc=$(cat $CMDS_DIR/new-import | jq .desc -r)
	pin-describe $sha1
	echo "New description: \"$new_desc\""
	confirm "Append description?"
	if [ "$?" = "1" ]; then
	    rm $CMDS_DIR/new-import
	    return 0
	fi
	jq --arg arg ". $new_desc" '.desc+=$arg' $CMDS_DIR/$sha1 > $CMDS_DIR/new-import
    fi
    mv $CMDS_DIR/new-import $CMDS_DIR/$sha1
    echo "Imported $sha1."
    pin-describe $sha1
    return 0
}

function pin-save() {
    cmdfile="$1"
    echo -n "Short Description (enter to skip): "
    pin-read-handler description
    if [ "$2" = "notrim" ]; then
	command="$(cat $cmdfile)"
    else
	command="$(cat $cmdfile | xargs)"
    fi
    echo -E """{\"cmd\": \"${command}\", \"desc\": \"${description}\"}""" | jq . > $cmdfile
    id=$(echo $command | sha1sum - | cut -d " " -f1)
    mv $cmdfile $CMDS_DIR/$id
    echo "Created $id."
    echo -n "Alias (enter to skip): "
    pin-read-handler alias
    if [ "$alias" != "" ]; then
	if [ $(echo $alias | wc -w) = "1" ]; then
	    ln -s $CMDS_DIR/$id $CMDS_DIR/$alias
	    echo "Create alias \"$alias\"."
	else
	    echo "Error: alias can only be one word."
	fi
    fi
}

function pin-run() {
    if [ "$RUN_COMMAND" = "1" ]; then
	ran_saved=1
	pin-exec $@
	rc=$?
	if [ "$ran_saved" = "1" ]; then
	    exit $rc
	fi
	echo -n "Save command [y/N]? "
	pin-read-handler save
	if [ "$save" != "y" -a "$save" != "Y" ]; then
	    exit $rc
	fi
    else
	rc=0
    fi

    ## Save this command
    echo ""
    a=($(echo $@ | xargs))
    i=0
    echo -n "Command entered: "
    for word in ${a[@]}; do
	echo -en "$YELLOW($i)$STOP$word "
	i=$((i+1))
    done
    echo -e ""
    echo -n "Enter the indices from above command that are arguments (enter to skip): "
    pin-read-handler args
    b=""
    for word in $args; do
	a[$word]="ARG"
    done
    b=""
    for word in ${a[@]}; do
	b=$(echo -n "$b $word")
    done
    echo "$b" > $TMP_CMD_FILE
    echo -e "Command to be saved: $YELLOW$b$STOP"
    pin-save $TMP_CMD_FILE
    exit $rc
}

function confirm() {
    echo -n "$1 [y/N]: "
    pin-read-handler cnf
    if [ "$cnf" != "y" -a "$cnf" != "Y" ]; then
	echo "Cancelled."
	return 1
    fi
    return 0
}

function pin-rm {
    cmd=$1
    filename=$(lookup-filename $cmd)
    if [ "$?" != "0" ]; then
	return $?
    fi
    pin-describe $cmd
    confirm "Delete above command?" || return 0
    rm $filename
    find $CMDS_DIR -xtype l -delete
    echo "Deleted."
}

function pin-describe {
    filename=$(lookup-filename $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	exit 1
    fi
    if [ "$COLOURED_OUTPUT" != "false" ]; then
	echo "SHA1:		$(tput bold)$(basename $filename)$(tput sgr0)"
	echo "Command:	$(tput bold)$(cat $filename | jq -r .cmd)$(tput sgr0)"
	echo "Description:	$(cat $filename | jq -r .desc)"
    else
	echo "SHA1:		$(basename $filename)"
	echo "Command:	$(cat $filename | jq -r .cmd)"
	echo "Description:	$(cat $filename | jq -r .desc)"
    fi
}

function pin-grep {
    jq -s . $(list-all-cmds) | jq 'to_entries' | \
	jq --arg filter $1 \
	   '.[] | select((.value.desc | contains($filter)) or (.value.cmd | contains($filter))) | [.key, .value.cmd, .value.desc] | @csv' | \
	parse-cmd-out
}

function pin-alias {
    if [ "o$#" != 2 ]; then
	echo "Usage: $PROGNAME alias <command-id> <alias>"
	exit 1
    fi
    filename=$(lookup-filename $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	exit 1
    fi
    ln -s $filename $CMDS_DIR/$2
    echo "Created alias $2 for command $1"
}

if [ "$PIN_CFG" != "" ]; then
    CFG=$PIN_CFG
fi

if [ ! -f $CFG ]; then
    pin-install
    exit 0
fi

. $CFG

if [ "$#" = "0" ]; then
    pin-usage
    exit 1
fi

if [ "$COLOURED_OUTPUT" != "false" ]; then
    YELLOW="\033[0;33m"
    STOP="\033[0m"
fi

if [ "$1" = "ls" ]; then
    pin-ls
elif [ "$1" = "rm" ]; then
    shift
    pin-rm $@
elif [ "$1" = "sync" ]; then
    pin-sync
elif [ "$1" = "import" ]; then
    pin-import $2
elif [ "$1" = "import-b64" ]; then
    pin-import $2 b64
elif [ "$1" = "export" ]; then
    pin-export $2
elif [ "$1" = "export-b64" ]; then
    pin-export $2 b64
elif [ "$1" = "grep" ]; then
    pin-grep $2
elif [ "$1" = "help" ]; then
    pin-usage
elif [ "$1" = "desc" ]; then
    pin-describe $2
elif [ "$1" = "run" ]; then
    shift
    pin-run $@
elif [ "$1" = "alias" ]; then
    shift
    pin-alias $@
elif [ "$1" = "tags" ]; then
    shift
    pin-tags $@
elif [ "$1" = "save" ]; then
    RUN_COMMAND=0
    shift
    pin-run $@
elif [ "$1" = "fork" ]; then
    shift
    pin-fork $@
elif [ "$1" = "install" ]; then
    pin-install
elif [ "$1" = "create" ]; then
    pin-create
elif [ "$1" = "generate-b64" ]; then
    pin-generate-b64
elif [ "$1" = "test" ]; then
    pin-test
else
    echo "Unknown command $1."
    pin-usage
    exit 1
fi
