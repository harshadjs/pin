#!/bin/bash

## Environment Variables
##
## PIN_INPUT=<filename> Turns pin into non-interactive mode.
##                      if set, pin will read line by line from
##                      <filename> whenever interactions are happening.
## PIN_CFG=<filename>   Makes pin use alternate config file instead
##                      of ~/.pin
## PIN_USE_CACHED=1	Doesn't ask for user input whenever cached
##			values are available

## Global Constants
REPO=$(dirname $BASH_SOURCE[0])
PROGNAME="pin"
CFG=~/.pin
TMP_CMD_FILE=.cmd
SYNC_SCRIPT=$REPO/pin-sync.sh
URL_REGEX='(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
CACHE=~/.pin-cache
ALIAS_FILE=~/.pin-alias

## Global Control Variables
g_pin_input_line=1
g_pin_input_cached=0
g_add_blob_tag=0

## Helper functions
function _read() {
    if [ "$PIN_INPUT" != "" ]; then
	val=$(echo '$(sed "${g_pin_input_line}q;d" $PIN_INPUT)')
	eval $1=$val
	g_pin_input_line=$((g_pin_input_line+1))
	if [ "$g_pin_input_cached" != "0" ]; then
	    eval c=\$$1
	    echo -n [$c]
	    if [ "$PIN_USE_CACHED" = "" ]; then
		read newval < /dev/tty
	    else
		echo ""
	    fi
	    if [ "$newval" != "" ]; then
		eval $1=$newval
	    fi
	else
	    echo ""
	fi
    else
	read $1 < /dev/tty
    fi
}

function _confirm() {
    echo -n "$1 [y/N]: "
    _read cnf
    if [ "$cnf" != "y" -a "$cnf" != "Y" ]; then
	echo "Cancelled."
	return 1
    fi
    return 0
}

function _check_dependency() {
    command -v $1 > /dev/null
    if [ "$?" != "0" ]; then
	return 1
    fi
    return 0
}

function _fail() {
    echo $1
    exit 1
}

function _list_all() {
    ls $CMDS_DIR/* -tr 2>/dev/null | grep -v ".git"
}

## Lookup a command
## $1:  SHA1 of the command
function _lookup() {
    if [ -f $CMDS_DIR/$1 ]; then
	echo $CMDS_DIR/$1
	return 0
    fi
    i=0
    for filename in $(_list_all); do
	if [ "$i" = "$1" ]; then
	    echo $filename
	    return 0
	fi
	i=$((i+1))
    done
    return 1
}

function _save() {
    cmdfile="$1"
    echo -n "Short Description (enter to skip): "
    _read description
    if [ "$2" = "notrim" ]; then
	command="$(cat $cmdfile)"
    else
	command="$(cat $cmdfile | xargs)"
    fi
    echo -n "Alias (enter to skip): "
    _read alias
    if [ "$g_add_blob_tag" = "1" ]; then
	description=$(echo "$description :blob:")
    fi
    echo -E """{\"cmd\": \"${command}\", \"desc\": \"${description}\"}""" | jq . > $cmdfile
    id=$(echo $command | sha1sum - | cut -d " " -f1)
    if [ "$alias" != "" ]; then
	echo "alias ${alias}= \"pin run $id\"" >> $ALIAS_FILE
    fi
    mv $cmdfile $CMDS_DIR/$id
    echo "Created $id."
}

function _parse_cmds() {
    if [ "$COLOURED_OUTPUT" = "false" ]; then
	awk -v FS=","		\
	    '''BEGIN{
		print "ID\tCommand";
		print "==============="}
		{
			printf "%2s\t%.75s%s\n\t%s%s",
				substr($1,2,length($1)),
				substr($2,3,length($2)-4),
				(length($2) > 70 ? "..." : "" ),
				substr($3,3,length($3)-5),
				ORS
		}'''
    else
	awk -v FS=","		\
	    '''BEGIN{
		print "ID\tCommand";
		print "==============="}
		{
			printf "\033[1m%2s\033[0m\t\033[1m%.75s%s\033[0m\n\t%s%s",
				substr($1,2,length($1)),
				substr($2,3,length($2)-4),
				(length($2) > 70 ? "..." : "" ),
				substr($3,3,length($3)-5),
				ORS
		}'''
    fi
}

## Execute a command by either the index, SHA1, URL or as is
## $1:      Variable that will be set as 1 or 0 depending on whether
##          the command that was passed, if that was a saved command
##          or not
## ${@:2}:  Command / URL / SHA1 / index
function _exec() {
    ## Check if this is SHA1 or index
    ran_saved=$1
    shift
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	## Is it a url?
	if ! [[ $1 =~ $URL_REGEX ]]; then
	    ## Not a url, not a saved command, run as is.
	    eval $ran_saved=0
	    eval $@
	    return $?
	fi
	pin-import $1
	if [ "$?" != "0" ]; then
	    return $?
	fi
	filename=$(echo $CMDS_DIR/$(basename $1 | cut -d "-" -f 2))
    fi
    pin-describe $(basename $filename)
    eval $ran_saved=1
    echo "Executing this command..."
    line=$(cat $filename | jq -r .cmd)
    tokens=($line)
    i=0
    if [ "$PIN_INPUT" = "" -a -f $CACHE/$(basename $filename) ]; then
	g_pin_input_cached=1
	g_pin_input_line=2
	PIN_INPUT=$CACHE/$(basename $filename)
    fi
    cache_file=$(echo ${filename}.cache)
    echo "" > $cache_file
    for token in ${tokens[@]}; do
	if [ "$token" = "ARG" ]; then
	    if [ "$i" = "0" ]; then
		## print the start of the command only first time
		echo -e "${tokens[@]}"
	    fi
	    echo -en "${tokens[@]:0:$i} <Enter Value>: "
	    _read var
	    tokens[$i]=$var
	    echo "$var" >> $cache_file
	fi
	i=$((i+1))
    done
    mv $cache_file $CACHE/$(basename $filename)
    if [ "$g_pin_input_cached" = "1" ]; then
	g_pin_input_cached=0
	PIN_INPUT=""
    fi
    echo -e "$DARKGREENBG${tokens[@]}$STOP"
    $WATCH eval ${tokens[@]}
    return $?
}

##
## Handlers for subcommands
##
function pin-usage() {
    echo  """Usage: $PROGNAME COMMAND [ARGS]

Pin helps you organize your commands. COMMAND can be one of the
following:

   ls           List all saved commands
   run          Run a new or a saved command. If running a new command
                also, ask the user the command should be saved
   import       Import a command from URL
   import-b64   Import a command as a base64 string
   export       Export a command as a cl1p.net URL
   export-b64   Export a command as a base64 string
   rm           Remove a saved command
   grep         Search for commands
   help         Print this usage
   desc         Describe a saved command
   save         Save a new command (similar to run, except don't run)
   fork         Fork a command
   create       Create a new command. (useful for saving scripts)
   sync         Sync your commands to your own comamands store
   generate-b64 Generate pin.tar.xz.base64 file
   install      Install pin
   tags         List all tags

You can directly pass the index of the command or the SHA1 to run
the command."""
}

function pin-install() {
    echo "Welcome to $PROGNAME installation!"
    _check_dependency sha1sum || _check_dependency shasum || \
	_fail "sha1sum or shasum not found"
    _check_dependency jq || _fail "jq not found"
    _check_dependency base64 || _fail "base64 not found"
    echo -n "Command store directory path ($HOME/.pin-db): "
    _read dir
    if [ "$dir" = "" ]; then
	dir="$HOME/.pin-db"
    fi
    mkdir -p $dir
    echo CMDS_DIR=$dir > ${CFG}.tmp
    echo -n "Which folder should it install into ($HOME/bin): "
    _read install_dir
    if [ "$install_dir" = "" ]; then
	install_dir="$HOME/bin"
    fi
    if [ ! -d $install_dir ]; then
	_fail "Folder $install_dir not found. Exitting."
    fi
    cp -i $BASH_SOURCE $install_dir
    if [ "$?" != "0" ]; then
	_fail "Installation failed."
    fi
    if [ -f $SYNC_SCRIPT ]; then
	cp $SYNC_SCRIPT $install_dir
    fi
    echo "Ensure that $install_dir is in your PATH variable."
    mv ${CFG}.tmp $CFG
    echo "Add following line in your <sh>rc file for alias support:"
    echo ". $ALIAS_FILE "
    echo "Done. Prefix any command by \"pin run\" to get started."
}

function pin-sync() {
    cd $CMDS_DIR
    $SYNC_SCRIPT
}

function pin-generate-b64() {
    tar -cz $BASH_SOURCE | base64 > $PROGNAME.tar.xz.base64
    echo "$PROGNAME.tar.xz.base64 written."
}

function pin-export() {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	return 1
    fi
    sha1=$(basename $filename)
    pin-describe $sha1
    _confirm "Export above command?" || return 0
    if [ "$2" = "b64" ]; then
	base64 $filename
    else
	url=$(echo https://api.cl1p.net/$PROGNAME-$sha1-$(date +%s))
	curl -H "Content-Type: text/html; charset=UTF-8" -X POST --data "$(base64 $filename)" $url
	echo "Command exported at $url"
    fi
}

function pin-ls() {
    cnt=$(_list_all | wc -w)
    if [ "$cnt" = "0" ]; then
	return
    fi
    
    jq -s . $(_list_all) | jq 'to_entries' | \
	jq  '.[] | [.key, .value.cmd, .value.desc] | @csv' | _parse_cmds
}

function pin-tags() {
    grep -o ':\w*:' -R $CMDS_DIR -h --exclude-dir .git --color=auto | \
	sort --unique
}

function pin-fork() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi

    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	return
    fi

    cp $filename ${filename}.fork
    $EDITOR ${filename}.fork
    dest_filename=$(cat ${filename}.fork | jq -r .cmd | sha1sum - | \
			cut -d " " -f1 2>/dev/null)
    mv ${filename}.fork $CMDS_DIR/$dest_filename
    echo "Created $dest_filename"
}

function pin-create() {
    if [ "$EDITOR" = "" ]; then
	echo "\$EDITOR not set."
	return
    fi
    $EDITOR ".new-cmd"
    #sed 's/$/\\n/' .new-cmd | tr -d '\n' > .new-cmd-trimmed
    sed 's/$/;/' .new-cmd > .new-cmd-trimmed
    _save .new-cmd-trimmed #notrim
}

function pin-import() {
    if [ "$1" = "b64" ]; then
	echo "Text mode. Enter the string that you got from pin export-b64. Ctrl D to stop:"
	cat | base64 -d - > $CMDS_DIR/new-import
    else
	b64=$(curl $1)
	if [ "$?" != "0" ]; then
	    echo "Import failed."
	    return 1
	fi
	echo "$b64" | base64 -d - > $CMDS_DIR/new-import
    fi
    cmd=$(cat $CMDS_DIR/new-import | jq -r .cmd)
    if [ "$cmd" = "" ]; then
	echo "No command imported."
	rm $CMDS_DIR/new-import
	return 1
    fi
    sha1=$(cat $CMDS_DIR/new-import | jq -r .cmd | sha1sum - | cut -d " " -f1 2>/dev/null)
    if [ -f $CMDS_DIR/$sha1 ]; then
	echo "Command $sha1 exists."
	new_desc=$(cat $CMDS_DIR/new-import | jq .desc -r)
	pin-describe $sha1
	echo "New description: \"$new_desc\""
	_confirm "Append description?"
	if [ "$?" = "1" ]; then
	    rm $CMDS_DIR/new-import
	    return 0
	fi
	jq --arg arg ". $new_desc" '.desc+=$arg' $CMDS_DIR/$sha1 > $CMDS_DIR/new-import
    fi
    mv $CMDS_DIR/new-import $CMDS_DIR/$sha1
    echo "Imported $sha1."
    pin-describe $sha1
    return 0
}

function pin-save() {
    echo ""
    a=($(echo $@ | xargs))
    i=0
    echo -n "Command entered: "
    for word in ${a[@]}; do
	echo -en "$YELLOW($i)$STOP$word "
	i=$((i+1))
    done
    echo -e ""
    echo -n "Enter the indices from above command that are arguments (enter to skip): "
    _read args
    b=""
    for word in $args; do
	a[$word]="ARG"
    done
    b=""
    for word in ${a[@]}; do
	b=$(echo -n "$b $word")
    done
    echo "$b" > $TMP_CMD_FILE
    echo -e "Command to be saved: $YELLOW$b$STOP"
    _save $TMP_CMD_FILE
}

function pin-save-blob() {
    cat | base64 -w 0 > $TMP_CMD_FILE
    g_add_blob_tag=1
    _save $TMP_CMD_FILE notrim
}

function pin-rm {
    cmd=$1
    filename=$(_lookup $cmd)
    if [ "$?" != "0" ]; then
	return $?
    fi
    pin-describe $cmd
    _confirm "Delete above command?" || return 0
    rm $filename
    find $CMDS_DIR -xtype l -delete
    echo "Deleted."
}

function pin-describe {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	echo "Command not found."
	return 1
    fi
    if [ "$COLOURED_OUTPUT" != "false" ]; then
	echo "SHA1:		$(tput bold)$(basename $filename)$(tput sgr0)"
	echo "Command:	$(tput bold)$(cat $filename | jq -r .cmd)$(tput sgr0)"
	echo "Description:	$(cat $filename | jq -r .desc)"
    else
	echo "SHA1:		$(basename $filename)"
	echo "Command:	$(cat $filename | jq -r .cmd)"
	echo "Description:	$(cat $filename | jq -r .desc)"
    fi
}

function pin-read-blob {
    filename=$(_lookup $1)
    if [ "$?" != "0" ]; then
	_fail "Blob not found."
    fi
    grep ":blob:" $filename > /dev/null || _fail "Not a blob"
    cat $filename | jq -r .cmd | base64 -d
}

function pin-grep {
    jq -s . $(_list_all) | jq 'to_entries' | \
	jq --arg filter $1 \
	   '.[] | select((.value.desc | contains($filter)) or (.value.cmd | contains($filter))) | [.key, .value.cmd, .value.desc] | @csv' | \
	_parse_cmds
}


function main() {
    ## Should we use alternate config file?
    if [ "$PIN_CFG" != "" ]; then
	CFG=$PIN_CFG
    fi
    if [ "$PIN_CACHE" != "" ]; then
	CACHE=$PIN_CACHE
    fi
    mkdir -p $CACHE
    if [ "$PIN_ALIAS_FILE" != "" ]; then
	ALIAS_FILE=$PIN_ALIAS_FILE
    fi

    if [ ! -f $CFG ]; then
	pin-install
	exit 0
    fi

    . $CFG

    if [ "$#" = "0" ]; then
	pin-usage
	exit 1
    fi

    if [ "$COLOURED_OUTPUT" != "false" ]; then
	YELLOW="\033[0;33m"
	DARKGREENBG="\033[7;32m"
	STOP="\033[0m"
    fi

    case "$1" in
	"ls")
	    pin-ls
	    ;;
	"rm")
	    shift
	    pin-rm $@
	    ;;
	"sync")
	    pin-sync
	    ;;
	"import")
	    pin-import $2
	    ;;
	"import-b64")
	    pin-import $2 b64
	    ;;
	"export")
	    pin-export $2
	    ;;
	"export-b64")
	    pin-export $2 b64
	    ;;
	"grep")
	    pin-grep $2
	    ;;
	"help")
	    pin-usage
	    ;;
	"desc" | "describe")
	    pin-describe $2
	    ;;
	"watch")
	    WATCH=watch
	    ;&
	"run")
	    shift
	    _exec ran_saved $@
	    rc=$?
	    if [ "$ran_saved" = "1" ]; then
		exit $rc
	    fi
	    echo -n "Save command [y/N]? "
	    _read save
	    if [ "$save" != "y" -a "$save" != "Y" ]; then
		exit $rc
	    fi
	    ;;
	"tags")
	    shift
	    pin-tags $@
	    ;;
	"save")
	    shift
	    pin-save $@
	    ;;
	"save-blob")
	    shift
	    pin-save-blob
	    ;;
	"read-blob")
	    pin-read-blob $2
	    ;;
	"fork")
	    shift
	    pin-fork $@
	    ;;
	"install")
	    pin-install
	    ;;
	"create")
	    pin-create
	    ;;
	"generate-b64")
	    pin-generate-b64
	    ;;
	*)
	    echo "Unknown command $1."
	    pin-usage
    esac
}

main $@
